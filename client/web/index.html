<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="peerwave_client">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>peerwave_client</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
  <script>
    // Helper functions for URL-safe base64 encoding and decoding
    function base64UrlEncode(buffer) {
        return btoa(String.fromCharCode(...new Uint8Array(buffer)))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=+$/, '');
    }

    function base64UrlDecode(base64) {
        if (typeof base64 === 'string') {       
            base64 = base64
                .replace(/-/g, '+')
                .replace(/_/g, '/');
            // Pad with '=' to make the length a multiple of 4
            while (base64.length % 4) {
                base64 += '=';
            }
            return Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;
        } else {
            return null;
        }
    }


    window.webauthnLogin = async function(serverUrl, email, clientId, fromCustomTab) {
        console.log('[WEBAUTHN] webauthnLogin called with:', { serverUrl, email, clientId, fromCustomTab });
        try {
            // Check if WebAuthn is supported by the browser
            if (!window.PublicKeyCredential) {
                console.error('[WEBAUTHN] WebAuthn not supported');
                throw new Error('WebAuthn is not supported');
            }
            
            console.log('[WEBAUTHN] Fetching authentication challenge...');

            // Request a new WebAuthn credential from the server
            const credential = await fetch(serverUrl + '/webauthn/authenticate-challenge', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include',
                body: JSON.stringify({ 
                    email: email,
                    fromCustomTab: fromCustomTab === true 
                })
            }).then(response => {
                console.log('[WEBAUTHN] Challenge response status:', response.status);
                if (response.status !== 200) {
                    console.warn('[WEBAUTHN] Non-200 status, calling onWebAuthnSuccess');
                    window.onWebAuthnSuccess(response.status)
                }
                return response.json();
            });

            console.log("[WEBAUTHN] credential:", credential);
            
            // Extract state for Custom Tab CSRF protection
            const state = credential.state || null;
            if (fromCustomTab && state) {
                console.log('[WEBAUTHN] CSRF state received for Custom Tab auth');
            }

            // Create a new PublicKeyCredential object
            credential.challenge = base64UrlDecode(credential.challenge);
            if (credential.allowCredentials !== undefined) {
                credential.allowCredentials.forEach(cred => {
                    cred.id = base64UrlDecode(cred.id);
                });
            }

            // Use the PublicKeyCredential object to perform the WebAuthn authentication
            let assertion;
            try {
                assertion = await navigator.credentials.get({ publicKey: credential });
            } catch (err) {
                console.warn('WebAuthn authentication aborted or failed:', err);
                if (window.onWebAuthnAbort) {
                    window.onWebAuthnAbort(err && err.toString ? err.toString() : String(err));
                }
                return;
            }

            // Capture WebAuthn signature for encryption key derivation
            const credentialId = base64UrlEncode(assertion.rawId);
            const signature = base64UrlEncode(assertion.response.signature);
            
            // Pass to Dart for encryption key derivation
            if (window.onWebAuthnSignature) {
                window.onWebAuthnSignature(credentialId, signature);
            }

            // test
            console.log('base64UrlDecode input:', assertion.rawId, typeof assertion.rawId);
            const rawId = base64UrlEncode(assertion.rawId)
            console.log('base64UrlDecode input:', rawId, typeof rawId);
            // test end
            // Send the authentication assertion to the server for verification
            const authPayload = {
                email: email,
                clientId: clientId,
                fromCustomTab: fromCustomTab === true,
                assertion: {
                    id: assertion.id,
                    rawId: base64UrlEncode(assertion.rawId),
                    type: assertion.type,
                    response: {
                        authenticatorData: base64UrlEncode(assertion.response.authenticatorData),
                        clientDataJSON: base64UrlEncode(assertion.response.clientDataJSON),
                        signature: base64UrlEncode(assertion.response.signature),
                        userHandle: assertion.response.userHandle ? base64UrlEncode(assertion.response.userHandle) : null
                    }
                }
            };
            
            // Include CSRF state for Custom Tab authentication
            if (fromCustomTab && state) {
                authPayload.state = state;
                console.log('[WEBAUTHN] Including CSRF state in authenticate request');
            }
            
            const response = await fetch(serverUrl + '/webauthn/authenticate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include',
                body: JSON.stringify(authPayload)
            });

            if (response.redirected) {
                window.location.href = response.url;
                return;
            }

            if (response.status === 200 || response.status === 202) {
                if (window.onWebAuthnSuccess) {
                    // Parse response to extract authToken
                    const data = await response.json();
                    console.log('[WEBAUTHN] Response data:', data);
                    const authToken = data.authToken || null;
                    console.log('[WEBAUTHN] Extracted authToken:', authToken ? 'present' : 'null');
                    window.onWebAuthnSuccess(response.status, authToken);
                }
                return;
            }

            // Surface error details for debugging
            let bodyText = '';
            try {
                bodyText = await response.text();
            } catch (_) {}
            console.error('[WEBAUTHN] Authentication failed:', response.status, bodyText);
            if (window.onWebAuthnAbort) {
                window.onWebAuthnAbort(`Authentication failed: ${response.status} ${bodyText}`);
            }
            throw new Error(`Authentication failed: ${response.status}`);

        } catch (error) {
            console.error('WebAuthn authentication failed:', error);
        }
    }

window.webauthnRegister = async function(serverUrl, email) {
    try {
        // Step 1: Fetch registration challenge from the server
        const challengeResponse = await fetch(serverUrl + '/webauthn/register-challenge', {
            method: 'POST',
            credentials: 'include',
            headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: email })
        });
        const challenge = await challengeResponse.json();
        // Step 2: Convert challenge to ArrayBuffer
        challenge.challenge = base64UrlDecode(challenge.challenge);
        // Only decode if id is a string (for compatibility with backend)
        if (typeof challenge.user.id === 'string') {
            challenge.user.id = base64UrlDecode(challenge.user.id);
        }

        // LOG
        console.log("Challenge sent to navigator.credentials.create:", challenge);
        // Step 3: Create a new credential
        const credential = await navigator.credentials.create({ publicKey: challenge });
        // Step 4: Convert credential response to JSON
        const attestation = {
            id: credential.id,
            rawId: base64UrlEncode(credential.rawId),
            response: {
                attestationObject: base64UrlEncode(credential.response.attestationObject),
                clientDataJSON: base64UrlEncode(credential.response.clientDataJSON)
            },
            type: credential.type
        };
        // Step 5: Send registration response to the server
        const registerResponse = await fetch(serverUrl + '/webauthn/register', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ username: challenge.user.name, attestation })
        });
        return registerResponse.ok;
    } catch (error) {
        console.error('WebAuthn registration failed:', error);
        return false;
    }
};
</script>
    <script>
        window.fetchMagicKey = async function(url) {
            const response = await fetch(url, {
                method: 'GET',
                credentials: 'include'
            });
            return await response.text();
        }
    </script>
    <script>
        (function () {
            const pipState = { win: null, elements: {} };

            window.peerwaveDocPiPSupported = function () {
                return !!(window.documentPictureInPicture && documentPictureInPicture.requestWindow);
            };

            window.peerwaveDocPiPOpen = async function (options) {
                if (!window.peerwaveDocPiPSupported()) {
                    return false;
                }

                if (pipState.win && !pipState.win.closed) {
                    if (options && options.title) {
                        window.peerwaveDocPiPSetTitle(options.title);
                    }
                    if (options && options.status) {
                        window.peerwaveDocPiPSetStatus(options.status);
                    }
                    return true;
                }

                const width = options && options.width ? options.width : 360;
                const height = options && options.height ? options.height : 220;
                const title = options && options.title ? options.title : 'Video Call';
                const status = options && options.status ? options.status : 'Call active';

                const pipWindow = await documentPictureInPicture.requestWindow({ width, height });
                pipState.win = pipWindow;

                const doc = pipWindow.document;
                doc.body.style.margin = '0';
                doc.body.style.fontFamily = 'system-ui, -apple-system, Segoe UI, sans-serif';
                doc.body.style.background = '#111';
                doc.body.style.color = '#fff';

                const root = doc.createElement('div');
                root.style.display = 'flex';
                root.style.flexDirection = 'column';
                root.style.height = '100%';

                const header = doc.createElement('div');
                header.style.display = 'flex';
                header.style.alignItems = 'center';
                header.style.justifyContent = 'space-between';
                header.style.padding = '6px 8px';
                header.style.background = '#1b1b1b';
                header.style.borderBottom = '1px solid #2a2a2a';

                const titleEl = doc.createElement('div');
                titleEl.textContent = title;
                titleEl.style.fontSize = '12px';
                titleEl.style.fontWeight = '600';

                const statusEl = doc.createElement('div');
                statusEl.textContent = status;
                statusEl.style.fontSize = '10px';
                statusEl.style.opacity = '0.75';
                statusEl.style.marginTop = '2px';

                const titleWrap = doc.createElement('div');
                titleWrap.style.display = 'flex';
                titleWrap.style.flexDirection = 'column';
                titleWrap.appendChild(titleEl);
                titleWrap.appendChild(statusEl);

                const closeBtn = doc.createElement('button');
                closeBtn.textContent = 'Close';
                closeBtn.style.fontSize = '11px';
                closeBtn.style.padding = '4px 8px';
                closeBtn.style.border = '1px solid #444';
                closeBtn.style.background = '#1b1b1b';
                closeBtn.style.color = '#fff';
                closeBtn.style.borderRadius = '6px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.addEventListener('click', () => pipWindow.close());

                header.appendChild(titleWrap);
                header.appendChild(closeBtn);

                const contentWrapper = doc.createElement('div');
                contentWrapper.style.position = 'relative';
                contentWrapper.style.flex = '1';
                contentWrapper.style.display = 'flex';
                contentWrapper.style.flexDirection = 'column';
                contentWrapper.style.background = '#000';

                root.appendChild(header);
                root.appendChild(contentWrapper);
                doc.body.appendChild(root);

                pipState.elements = {
                    title: titleEl,
                    status: statusEl,
                    content: contentWrapper
                };

                pipWindow.addEventListener('pagehide', () => {
                    pipState.win = null;
                    pipState.elements = {};
                    if (window.peerwaveDocPiPOnClose) {
                        window.peerwaveDocPiPOnClose();
                    }
                });

                return true;
            };

            window.peerwaveDocPiPClose = async function () {
                if (pipState.win && !pipState.win.closed) {
                    pipState.win.close();
                }
                pipState.win = null;
                pipState.elements = {};
                return true;
            };

            window.peerwaveDocPiPSetStatus = function (text) {
                if (pipState.elements.status) {
                    pipState.elements.status.textContent = text || '';
                }
            };

            window.peerwaveDocPiPSetTitle = function (text) {
                if (pipState.elements.title) {
                    pipState.elements.title.textContent = text || '';
                }
            };

            function safePlay(video) {
                if (!video || typeof video.play !== 'function') {
                    return;
                }
                const playResult = video.play();
                if (playResult && typeof playResult.catch === 'function') {
                    playResult.catch(() => {});
                }
            }

            function toStream(source) {
                if (!source) {
                    return null;
                }
                if (source instanceof MediaStream) {
                    return source;
                }
                if (source instanceof MediaStreamTrack) {
                    const track = typeof source.clone === 'function' ? source.clone() : source;
                    return new MediaStream([track]);
                }
                return null;
            }

            function createTile(doc, tile) {
                const wrap = doc.createElement('div');
                wrap.style.position = 'relative';
                wrap.style.background = '#000';
                wrap.style.borderRadius = '6px';
                wrap.style.overflow = 'hidden';
                if (tile && tile.isSpeaking) {
                    wrap.style.outline = '2px solid #3bd671';
                }

                const video = doc.createElement('video');
                video.autoplay = true;
                video.playsInline = true;
                video.muted = true;
                video.style.width = '100%';
                video.style.height = '100%';
                video.style.objectFit = 'cover';
                const tileSource = tile ? (tile.track || tile.stream) : null;
                const tileStream = toStream(tileSource);
                if (tileStream) {
                    video.srcObject = tileStream;
                    safePlay(video);
                }

                if (!tileStream) {
                    const placeholder = doc.createElement('div');
                    placeholder.textContent = 'No video';
                    placeholder.style.position = 'absolute';
                    placeholder.style.top = '6px';
                    placeholder.style.left = '6px';
                    placeholder.style.fontSize = '10px';
                    placeholder.style.opacity = '0.65';
                    wrap.appendChild(placeholder);
                }

                const label = doc.createElement('div');
                label.textContent = tile && tile.label ? tile.label : '';
                label.style.position = 'absolute';
                label.style.left = '6px';
                label.style.bottom = '6px';
                label.style.fontSize = '10px';
                label.style.padding = '2px 6px';
                label.style.borderRadius = '4px';
                label.style.background = 'rgba(0,0,0,0.6)';
                label.style.color = '#fff';

                wrap.appendChild(video);
                wrap.appendChild(label);
                return wrap;
            }

            window.peerwaveDocPiPUpdateLayout = function (layout) {
                if (!pipState.elements.content) {
                    return;
                }

                const content = pipState.elements.content;
                while (content.firstChild) {
                    content.removeChild(content.firstChild);
                }

                if (layout && layout.title && pipState.elements.title) {
                    pipState.elements.title.textContent = layout.title;
                }
                if (layout && layout.status && pipState.elements.status) {
                    pipState.elements.status.textContent = layout.status;
                }

                const tiles = layout && Array.isArray(layout.tiles) ? layout.tiles : [];
                const screenSource = layout ? (layout.screenShare || layout.screenTrack) : null;
                const screenShare = toStream(screenSource);

                if (screenShare) {
                    const screenWrap = content.ownerDocument.createElement('div');
                    screenWrap.style.flex = '6';
                    screenWrap.style.position = 'relative';
                    screenWrap.style.borderBottom = '1px solid #1e1e1e';

                    const screenVideo = content.ownerDocument.createElement('video');
                    screenVideo.autoplay = true;
                    screenVideo.playsInline = true;
                    screenVideo.muted = true;
                    screenVideo.style.width = '100%';
                    screenVideo.style.height = '100%';
                    screenVideo.style.objectFit = 'contain';
                    screenVideo.srcObject = screenShare;
                    safePlay(screenVideo);

                    screenWrap.appendChild(screenVideo);
                    content.appendChild(screenWrap);

                    if (tiles.length) {
                        const row = content.ownerDocument.createElement('div');
                        row.style.flex = '4';
                        row.style.display = 'flex';
                        row.style.gap = '6px';
                        row.style.padding = '6px';
                        row.style.background = '#000';
                        tiles.slice(0, 3).forEach((tile) => {
                            const tileWrap = createTile(content.ownerDocument, tile);
                            tileWrap.style.flex = '1';
                            row.appendChild(tileWrap);
                        });
                        content.appendChild(row);
                    }
                    return;
                }

                const grid = content.ownerDocument.createElement('div');
                grid.style.display = 'grid';
                grid.style.flex = '1';
                grid.style.gap = '6px';
                grid.style.padding = '6px';
                const cols = tiles.length > 2 ? '1fr 1fr' : '1fr';
                grid.style.gridTemplateColumns = cols;

                tiles.forEach((tile) => {
                    grid.appendChild(createTile(content.ownerDocument, tile));
                });

                content.appendChild(grid);
            };
        })();
    </script>
</body>
</html>
