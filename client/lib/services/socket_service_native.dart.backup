import 'dart:async';
import 'package:flutter/foundation.dart' show debugPrint;
import 'package:socket_io_client/socket_io_client.dart' as io;
import '../core/metrics/network_metrics.dart';
import 'signal_service.dart';
import 'server_config_native.dart';
import 'auth_service_native.dart';
import 'session_auth_service.dart';
import 'clientid_native.dart';

/// Callback for handling socket unauthorized events
typedef SocketUnauthorizedCallback = void Function();

/// Global callback for socket unauthorized handling
SocketUnauthorizedCallback? _socketUnauthorizedCallback;

/// Set global socket unauthorized handler
void setSocketUnauthorizedHandler(SocketUnauthorizedCallback callback) {
  _socketUnauthorizedCallback = callback;
}

/// Native socket service - manages connections to ALL configured servers
/// API-compatible with web SocketService
class SocketService {
  static final SocketService _instance = SocketService._internal();
  factory SocketService() => _instance;
  SocketService._internal();

  // Map of serverId -> Socket instance (one socket per server)
  final Map<String, io.Socket> _sockets = {};
  final Map<String, bool> _serverConnecting = {};
  final Map<String, bool> _serverListenersRegistered = {};
  final Map<String, bool> _serverIsConnected = {};
  final Map<String, Completer<void>> _serverConnectionCompleters = {};
  
  String? _activeServerId; // Which server is currently active in UI
  final Map<String, List<void Function(dynamic)>> _listeners = {};

  // Get socket for active server
  io.Socket? get socket => _activeServerId != null ? _sockets[_activeServerId] : null;
  bool get isReady => _activeServerId != null && 
      (_serverListenersRegistered[_activeServerId] ?? false) && 
      (_sockets[_activeServerId]?.connected ?? false);

  bool get isConnected {
    if (_activeServerId == null) return false;
    final socket = _sockets[_activeServerId];
    final socketConnected = socket?.connected ?? false;
    final internalConnected = _serverIsConnected[_activeServerId] ?? false;

    debugPrint('[SOCKET SERVICE] >>> isConnected getter (active: $_activeServerId) <<<');
    debugPrint('[SOCKET SERVICE] socket.connected: $socketConnected, internal: $internalConnected');

    return internalConnected && socketConnected;
  }

  /// Connect to ALL configured servers (for background notifications)
  Future<void> connectAllServers() async {
    final servers = ServerConfigService.getAllServers();
    debugPrint('[SOCKET SERVICE] Connecting to ${servers.length} servers...');
    
    for (final server in servers) {
      try {
        await _connectToServer(server);
      } catch (e) {
        debugPrint('[SOCKET SERVICE] Failed to connect to ${server.serverUrl}: $e');
      }
    }
  }

  /// Set which server is currently active (for UI interactions)
  void setActiveServer(String serverId) {
    debugPrint('[SOCKET SERVICE] Setting active server: $serverId');
    _activeServerId = serverId;
  }

  /// Connect to active server only (legacy compatibility)
  Future<void> connect() async {
    final activeServer = ServerConfigService.getActiveServer();
    if (activeServer == null) {
      debugPrint('[SOCKET SERVICE] No active server configured');
      return;
    }

    _activeServerId = activeServer.id;
    await _connectToServer(activeServer);
  }

  /// Connect to a specific server
  Future<void> _connectToServer(ServerConfig server) async {

      String urlString = activeServer.serverUrl;
      if (!urlString.startsWith('http://') &&
          !urlString.startsWith('https://')) {
        urlString = 'https://$urlString';
      }

      _socket = io.io(urlString, <String, dynamic>{
        'transports': ['websocket'],
        'autoConnect': false,
        'reconnection': true,
        'reconnectionDelay': 2000,
        'reconnectionAttempts': 5,
        'forceNew': false,
        'timeout': 20000,
      });

      _socket!.on('connect', (_) async {
        debugPrint(
          '[SOCKET SERVICE] ==========================================',
        );
        debugPrint('[SOCKET SERVICE] ?? Socket connected event fired');
        debugPrint(
          '[SOCKET SERVICE]    Socket object exists: ${_socket != null}',
        );
        debugPrint('[SOCKET SERVICE]    Socket ID: ${_socket?.id}');
        debugPrint(
          '[SOCKET SERVICE]    Stored listeners count: ${_listeners.length}',
        );
        debugPrint(
          '[SOCKET SERVICE] ==========================================',
        );

        // Set internal connection state
        _isConnected = true;

        // Re-register all stored listeners on connect
        _reregisterAllListeners();

        await _authenticate();
      });

      _socket!.on('authenticated', (data) {
        debugPrint('[SOCKET SERVICE] ?? Authenticated event received: $data');
        _handleAuthenticated(data);
        // Complete the connection future after successful authentication
        if (data is Map && data['authenticated'] == true) {
          if (!_connectionCompleter!.isCompleted) {
            _connectionCompleter!.complete();
            debugPrint(
              '[SOCKET SERVICE] ? Connection and authentication complete',
            );
          }
        } else if (data is Map && data['authenticated'] == false) {
          debugPrint(
            '[SOCKET SERVICE] ? Authentication failed: ${data['error']}',
          );
          if (!_connectionCompleter!.isCompleted) {
            _connectionCompleter!.completeError(
              'Authentication failed: ${data['error']}',
            );
          }
        }
      });

      _socket!.on('disconnect', (reason) {
        debugPrint('[SOCKET SERVICE] ? Disconnected: $reason');
        _isConnected = false; // Update internal state
        // Don't reset ready state on disconnect - we'll re-send clientReady on reconnect
        // resetReadyState();
      });
      _socket!.on('reconnect', (_) async {
        debugPrint('[SOCKET SERVICE] ?? Socket reconnected');
        await _authenticate();
        // After successful reconnect and auth, notify ready if listeners were registered
        if (_listenersRegistered) {
          debugPrint(
            '[SOCKET SERVICE] ?? Reconnected - re-sending clientReady',
          );
          _socket!.emit('clientReady', {
            'timestamp': DateTime.now().toIso8601String(),
          });
        }
      });
      _socket!.on('connect_error', (error) {
        debugPrint('[SOCKET SERVICE] ? Connection error: $error');
        debugPrint('[SOCKET SERVICE] Error type: ${error.runtimeType}');

        // DNS resolution failures are common on mobile after app resume
        if (error.toString().contains('Failed host lookup')) {
          debugPrint(
            '[SOCKET SERVICE] ‚ö†Ô∏è DNS lookup failed - network may not be ready yet',
          );
          debugPrint('[SOCKET SERVICE] Socket.IO will retry automatically');
        }
      });
      _socket!.on('connect_timeout', (_) {
        debugPrint('[SOCKET SERVICE] ? Connection timeout');
      });
      _socket!.on('unauthorized', (_) {
        if (AuthService.isLoggedIn) {
          _socketUnauthorizedCallback?.call();
        }
      });
      _socket!.on('error', (data) {
        debugPrint('[SOCKET SERVICE] Socket error: $data');
        if (data is Map &&
            (data['message']?.toString().contains('unauthorized') ?? false)) {
          if (AuthService.isLoggedIn) _socketUnauthorizedCallback?.call();
        }
        // Complete with error if connection fails
        if (!_connectionCompleter!.isCompleted) {
          _connectionCompleter!.completeError('Socket connection error: $data');
        }
      });

      _listeners.forEach((event, callbacks) {
        for (var cb in callbacks) {
          _socket!.on(event, cb);
        }
      });

      debugPrint('[SOCKET SERVICE] Starting socket connection...');
      _socket!.connect();

      // Wait for authentication to complete (with timeout)
      await _connectionCompleter!.future.timeout(
        Duration(seconds: 10),
        onTimeout: () {
          debugPrint('[SOCKET SERVICE] ? Connection timeout after 10 seconds');
          throw TimeoutException('Socket connection timeout');
        },
      );

      debugPrint(
        '[SOCKET SERVICE] ? Connect method completing, socket connected: ${_socket?.connected}',
      );
      debugPrint('[SOCKET SERVICE] isConnected getter returns: $isConnected');
      debugPrint('[SOCKET SERVICE] isReady getter returns: $isReady');
    } catch (e) {
      debugPrint('[SOCKET SERVICE] ? Connection error: $e');
      if (!_connectionCompleter!.isCompleted) {
        _connectionCompleter!.completeError(e);
      }
      rethrow;
    } finally {
      _connecting = false;
    }
  }

  void _handleAuthenticated(dynamic data) {
    debugPrint('[SOCKET SERVICE] Authenticated: $data');
    debugPrint(
      '[SOCKET SERVICE] Socket state after auth: connected=${_socket?.connected}, id=${_socket?.id}',
    );
    if (data is Map && data['authenticated'] == false) {
      if (AuthService.isLoggedIn) _socketUnauthorizedCallback?.call();
      return;
    }
    if (data is Map &&
        data['authenticated'] == true &&
        data['uuid'] != null &&
        data['deviceId'] != null) {
      final deviceId = data['deviceId'] is int
          ? data['deviceId']
          : int.parse(data['deviceId'].toString());
      SignalService.instance.setCurrentUserInfo(data['uuid'], deviceId);
      debugPrint(
        '[SOCKET SERVICE] User info set, socket still connected: ${_socket?.connected}',
      );

      // ?? CRITICAL: If listeners are already registered, notify server immediately after auth
      if (_listenersRegistered) {
        debugPrint(
          '[SOCKET SERVICE] ?? Authentication complete & listeners registered - notifying server',
        );
        if (_socket?.connected ?? false) {
          _socket!.emit('clientReady', {
            'timestamp': DateTime.now().toIso8601String(),
          });
          debugPrint(
            '[SOCKET SERVICE] ‚úÖ clientReady sent immediately after auth',
          );
        } else {
          debugPrint(
            '[SOCKET SERVICE] ‚ö†Ô∏è Socket not connected, cannot send clientReady yet',
          );
        }
      } else {
        debugPrint(
          '[SOCKET SERVICE] Authentication complete but listeners not yet registered - will notify when ready',
        );
      }
    }
  }

  Future<void> _authenticate() async {
    try {
      debugPrint('[SOCKET SERVICE] Starting authentication...');
      final clientId = await ClientIdService.getClientId();
      debugPrint('[SOCKET SERVICE] Got client ID: $clientId');
      
      // Get active server URL for multi-server support
      final activeServer = ServerConfigService.getActiveServer();
      if (activeServer == null) {
        debugPrint('[SOCKET SERVICE] ‚ö†Ô∏è No active server configured');
        return;
      }
      final serverUrl = activeServer.serverUrl;
      
      final authHeaders = await SessionAuthService().generateAuthHeaders(
        clientId: clientId,
        requestPath: '/socket.io/auth',
        serverUrl: serverUrl,
        requestBody: null,
      );
      debugPrint(
        '[SOCKET SERVICE] Generated auth headers @ $serverUrl, emitting authenticate event',
      );
      _socket!.emit('authenticate', authHeaders);
      debugPrint(
        '[SOCKET SERVICE] Authenticate event emitted, waiting for response...',
      );
    } catch (e) {
      debugPrint('[SOCKET SERVICE] ? Auth error: $e');
      rethrow;
    }

  void disconnect() {
    resetReadyState();
    _socket?.disconnect();
    _socket = null;
    _currentServerId = null;
  }

  void registerListener(String event, Function(dynamic) callback) {
    debugPrint('[SOCKET SERVICE] ?? registerListener called for event: $event');
    debugPrint(
      '[SOCKET SERVICE]    Socket exists: ${_socket != null}, connected: ${_socket?.connected}',
    );

    final callbacks = _listeners.putIfAbsent(event, () => []);
    if (!callbacks.contains(callback)) {
      callbacks.add(callback);
      debugPrint(
        '[SOCKET SERVICE]    ? Callback stored in _listeners map (total for $event: ${callbacks.length})',
      );

      // Only register immediately if socket is connected
      if (_socket?.connected ?? false) {
        // Wrap callback to track receives
        void wrappedCallback(dynamic data) {
          NetworkMetrics.recordSocketReceive(1);
          callback(data);
        }

        _socket!.on(event, wrappedCallback);
        debugPrint(
          '[SOCKET SERVICE]    ? Callback registered on socket immediately',
        );
      } else {
        debugPrint(
          '[SOCKET SERVICE]    ? Socket not connected, callback stored for later registration',
        );
      }
    } else {
      debugPrint(
        '[SOCKET SERVICE]    ??  Callback already registered for event: $event',
      );
    }
  }

  /// Re-register all stored listeners on the socket
  /// Called when socket connects/reconnects
  void _reregisterAllListeners() {
    if (_socket == null) {
      debugPrint(
        '[SOCKET SERVICE] ??  Cannot re-register listeners - socket is null',
      );
      return;
    }

    debugPrint(
      '[SOCKET SERVICE] ?? Re-registering ${_listeners.length} event listeners...',
    );
    int totalCallbacks = 0;

    _listeners.forEach((event, callbacks) {
      debugPrint(
        '[SOCKET SERVICE]    Re-registering $event (${callbacks.length} callbacks)',
      );
      for (final callback in callbacks) {
        // Wrap callback to track receives
        void wrappedCallback(dynamic data) {
          NetworkMetrics.recordSocketReceive(1);
          callback(data);
        }

        _socket!.on(event, wrappedCallback);
        totalCallbacks++;
      }
    });

    debugPrint(
      '[SOCKET SERVICE] ? Re-registered $totalCallbacks total callbacks across ${_listeners.length} events',
    );
  }

  void notifyClientReady() {
    debugPrint(
      '[SOCKET SERVICE] üìû notifyClientReady called - socket connected: ${_socket?.connected}, isConnected: $isConnected',
    );
    debugPrint(
      '[SOCKET SERVICE]    Current state: _listenersRegistered=$_listenersRegistered',
    );
    if (_socket?.connected ?? false) {
      _listenersRegistered = true;
      debugPrint('[SOCKET SERVICE] ?? Client ready - notifying server');
      _socket!.emit('clientReady', {
        'timestamp': DateTime.now().toIso8601String(),
      });
      debugPrint('[SOCKET SERVICE] ‚úÖ clientReady event emitted successfully');
    } else {
      debugPrint(
        '[SOCKET SERVICE] ‚ö†Ô∏è Cannot notify ready - socket not connected',
      );
      debugPrint('[SOCKET SERVICE] Socket object exists: ${_socket != null}');
      if (_socket != null) {
        debugPrint(
          '[SOCKET SERVICE] Socket ID: ${_socket!.id}, Connected: ${_socket!.connected}',
        );
      }

      // Set flag anyway so it will be sent after connection completes
      _listenersRegistered = true;
      debugPrint(
        '[SOCKET SERVICE] ‚è≥ Marked listeners as registered - will send clientReady after connection',
      );
    }
  }

  void resetReadyState() => _listenersRegistered = false;
  void unregisterListener(String event, Function(dynamic) callback) {
    _listeners[event]?.remove(callback);
    _socket?.off(event, callback);
  }

  void emit(String event, dynamic data) {
    _socket?.emit(event, data);
    // Track socket emit
    NetworkMetrics.recordSocketEmit(1);
  }

  void authenticate() => _authenticate();
}
